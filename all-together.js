

// Generated by CoffeeScript 1.10.0
(function() {
  var _Audio,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _Audio = (function() {
    var _audioContext, _defaultOptions, _errorCallbacks, _startCallbacks, _updateCallbacks;

    _audioContext = window.AudioContext || window.webkitAudioContext;

    _startCallbacks = [];

    _updateCallbacks = [];

    _errorCallbacks = [];

    _defaultOptions = {
      alpha: 0.5,
      sampleSize: 2048,
      spectrumStart: 18,
      spectrumRange: 38
    };

    function _Audio(opts) {
      var i, key, val;
      if (opts == null) {
        opts = {};
      }
      this.startRecording = bind(this.startRecording, this);
      this.setupStream = bind(this.setupStream, this);
      this.analyse = bind(this.analyse, this);
      if (!_audioContext) {
        return;
      }
      this.context = new _audioContext();
      this.options = _defaultOptions;
      for (key in opts) {
        val = opts[key];
        this.options[key] = val;
      }
      this.buffer = new Uint8Array(this.options.sampleSize / 2);
      this.fft = new FFT(this.options.sampleSize / 2, this.context.sampleRate);
      this.spectrum = (function() {
        var j, ref, results;
        results = [];
        for (i = j = 0, ref = this.options.spectrumRange; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
          results.push(0);
        }
        return results;
      }).call(this);
      this.stats = {};
    }

    _Audio.prototype.analyse = function() {
      var fn, i, j, k, len, mag, newBinVal, opts, ref, results, s;
      window.requestAnimationFrame(this.analyse);
      this.analyser.getByteTimeDomainData(this.buffer);
      this.fft.forward(this.buffer);
      s = this.stats;
      s.maxBinFreq = 0;
      s.maxBinVal = 0;
      s.totalVal = 0;
      opts = this.options;
      for (i = j = 0, ref = opts.spectrumRange; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        mag = this.fft.spectrum[i + opts.spectrumStart];
        newBinVal = (1.0 - opts.alpha) * +mag * opts.alpha;
        if (newBinVal > s.maxBinVal) {
          s.maxBinFreq = this.frequencyFromBin(i + opts.spectrumStart);
          s.maxBinVal = newBinVal;
        }
        s.totalVal += newBinVal;
        this.spectrum[i] = newBinVal;
      }
      results = [];
      for (k = 0, len = _updateCallbacks.length; k < len; k++) {
        fn = _updateCallbacks[k];
        results.push(fn(this));
      }
      return results;
    };

    _Audio.prototype.setupStream = function(stream) {
      var fn, j, len;
      this.stream = this.context.createMediaStreamSource(stream);
      this.analyser = this.context.createAnalyser();
      this.analyser.fftSize = 2048;
      this.stream.connect(this.analyser);
      for (j = 0, len = _startCallbacks.length; j < len; j++) {
        fn = _startCallbacks[j];
        fn();
      }
      return this.analyse();
    };

    _Audio.prototype.onError = function(fn) {
      return _errorCallbacks.push(fn);
    };

    _Audio.prototype.onStart = function(fn) {
      return _startCallbacks.push(fn);
    };

    _Audio.prototype.onUpdate = function(fn) {
      return _updateCallbacks.push(fn);
    };

    _Audio.prototype.startRecording = function() {
      if (!this.context) {
        return;
      }
      return this.getUserMedia({
        audio: true
      }, this.setupStream);
    };

    _Audio.prototype.getUserMedia = function(dictionary, callback) {
      var e, error;
      try {
        navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
        return navigator.getUserMedia(dictionary, callback, function() {
          var fn, j, len, results;
          results = [];
          for (j = 0, len = _errorCallbacks.length; j < len; j++) {
            fn = _errorCallbacks[j];
            results.push(fn());
          }
          return results;
        });
      } catch (error) {
        e = error;
        return typeof this.onError === "function" ? this.onError('getUserMedia threw exception :' + e) : void 0;
      }
    };

    _Audio.prototype.centFromFrequency = function(f) {
      var noteNum;
      if (f == null) {
        f = 0;
      }
      if (f === 0) {
        return 0;
      }
      noteNum = 12 * (Math.log(f / 440) / Math.log(2));
      return Math.round(noteNum * 10) + 690;
    };

    _Audio.prototype.frequencyFromBin = function(b) {
      return b * this.context.sampleRate / this.options.sampleSize;
    };

    return _Audio;

  })();

  window.Audio = new _Audio;

}).call(this);

/*
 *  DSP.js - a comprehensive digital signal processing  library for javascript
 *
 *  Created by Corban Brook <corbanbrook@gmail.com> on 2010-01-01.
 *  Copyright 2010 Corban Brook. All rights reserved.
 *
 */

// Fourier Transform Module used by DFT, FFT, RFFT
function FourierTransform(bufferSize, sampleRate) {
  this.bufferSize = bufferSize;
  this.sampleRate = sampleRate;
  this.bandwidth  = 2 / bufferSize * sampleRate / 2;

  this.spectrum   = new Float32Array(bufferSize/2);
  this.real       = new Float32Array(bufferSize);
  this.imag       = new Float32Array(bufferSize);

  this.peakBand   = 0;
  this.peak       = 0;

  /**
   * Calculates the *middle* frequency of an FFT band.
   *
   * @param {Number} index The index of the FFT band.
   *
   * @returns The middle frequency in Hz.
   */
  this.getBandFrequency = function(index) {
    return this.bandwidth * index + this.bandwidth / 2;
  };

  this.calculateSpectrum = function() {
    var spectrum  = this.spectrum,
        real      = this.real,
        imag      = this.imag,
        bSi       = 2 / this.bufferSize,
        sqrt      = Math.sqrt,
        rval,
        ival,
        mag;

    for (var i = 0, N = bufferSize/2; i < N; i++) {
      rval = real[i];
      ival = imag[i];
      mag = bSi * sqrt(rval * rval + ival * ival);

      if (mag > this.peak) {
        this.peakBand = i;
        this.peak = mag;
      }

      spectrum[i] = mag;
    }
  };
}

/**
 * FFT is a class for calculating the Discrete Fourier Transform of a signal
 * with the Fast Fourier Transform algorithm.
 *
 * @param {Number} bufferSize The size of the sample buffer to be computed. Must be power of 2
 * @param {Number} sampleRate The sampleRate of the buffer (eg. 44100)
 *
 * @constructor
 */
function FFT(bufferSize, sampleRate) {
  FourierTransform.call(this, bufferSize, sampleRate);

  this.reverseTable = new Uint32Array(bufferSize);

  var limit = 1;
  var bit = bufferSize >> 1;

  var i;

  while (limit < bufferSize) {
    for (i = 0; i < limit; i++) {
      this.reverseTable[i + limit] = this.reverseTable[i] + bit;
    }

    limit = limit << 1;
    bit = bit >> 1;
  }

  this.sinTable = new Float32Array(bufferSize);
  this.cosTable = new Float32Array(bufferSize);

  for (i = 0; i < bufferSize; i++) {
    this.sinTable[i] = Math.sin(-Math.PI/i);
    this.cosTable[i] = Math.cos(-Math.PI/i);
  }
}

/**
 * Performs a forward transform on the sample buffer.
 * Converts a time domain signal to frequency domain spectra.
 *
 * @param {Array} buffer The sample buffer. Buffer Length must be power of 2
 *
 * @returns The frequency spectrum array
 */
FFT.prototype.forward = function(buffer) {
  // Locally scope variables for speed up
  var bufferSize      = this.bufferSize,
      cosTable        = this.cosTable,
      sinTable        = this.sinTable,
      reverseTable    = this.reverseTable,
      real            = this.real,
      imag            = this.imag,
      spectrum        = this.spectrum;

  var k = Math.floor(Math.log(bufferSize) / Math.LN2);

  if (Math.pow(2, k) !== bufferSize) { throw "Invalid buffer size, must be a power of 2."; }
  if (bufferSize !== buffer.length)  { throw "Supplied buffer is not the same size as defined FFT. FFT Size: " + bufferSize + " Buffer Size: " + buffer.length; }

  var halfSize = 1,
      phaseShiftStepReal,
      phaseShiftStepImag,
      currentPhaseShiftReal,
      currentPhaseShiftImag,
      off,
      tr,
      ti,
      tmpReal,
      i;

  for (i = 0; i < bufferSize; i++) {
    real[i] = buffer[reverseTable[i]];
    imag[i] = 0;
  }

  while (halfSize < bufferSize) {
    //phaseShiftStepReal = Math.cos(-Math.PI/halfSize);
    //phaseShiftStepImag = Math.sin(-Math.PI/halfSize);
    phaseShiftStepReal = cosTable[halfSize];
    phaseShiftStepImag = sinTable[halfSize];

    currentPhaseShiftReal = 1;
    currentPhaseShiftImag = 0;

    for (var fftStep = 0; fftStep < halfSize; fftStep++) {
      i = fftStep;

      while (i < bufferSize) {
        off = i + halfSize;
        tr = (currentPhaseShiftReal * real[off]) - (currentPhaseShiftImag * imag[off]);
        ti = (currentPhaseShiftReal * imag[off]) + (currentPhaseShiftImag * real[off]);

        real[off] = real[i] - tr;
        imag[off] = imag[i] - ti;
        real[i] += tr;
        imag[i] += ti;

        i += halfSize << 1;
      }

      tmpReal = currentPhaseShiftReal;
      currentPhaseShiftReal = (tmpReal * phaseShiftStepReal) - (currentPhaseShiftImag * phaseShiftStepImag);
      currentPhaseShiftImag = (tmpReal * phaseShiftStepImag) + (currentPhaseShiftImag * phaseShiftStepReal);
    }

    halfSize = halfSize << 1;
  }

  return this.calculateSpectrum();
};

// Generated by CoffeeScript 1.10.0
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  window.NoteRecorder = (function() {
    var _defaultOptions, _idleCallbacks, _updateCallbacks;

    _updateCallbacks = [];

    _idleCallbacks = [];

    _defaultOptions = {
      tolerance: 10,
      minDuration: 30,
      idleTimeout: 30
    };

    function NoteRecorder(audio, opts) {
      var key, val;
      if (opts == null) {
        opts = {};
      }
      this.analyse = bind(this.analyse, this);
      audio.onUpdate(this.analyse);
      this.options = _defaultOptions;
      for (key in opts) {
        val = opts[key];
        this.options[key] = val;
      }
      this.lastNote = 0;
      this.pitchDuration = 0;
      this.reset();
    }

    NoteRecorder.prototype.analyse = function(audio) {
      var fn, j, k, len, len1, note, o;
      o = this.options;
      note = audio.centFromFrequency(audio.stats.maxBinFreq);
      if (note >= this.lastNote - o.tolerance && note <= this.lastNote + o.tolerance) {
        this.pitchDuration++;
      } else {
        if (this.pitchDuration > o.minDuration) {
          this.sequence.push(this.lastNote);
          this.idleDuration = 0;
          for (j = 0, len = _updateCallbacks.length; j < len; j++) {
            fn = _updateCallbacks[j];
            fn();
          }
        } else {
          this.idleDuration++;
        }
        this.lastNote = 0;
        this.pitchDuration = 0;
      }
      if (this.idleDuration > o.idleTimeout) {
        for (k = 0, len1 = _idleCallbacks.length; k < len1; k++) {
          fn = _idleCallbacks[k];
          fn();
        }
        this.reset();
      }
      return this.lastNote = note;
    };

    NoteRecorder.prototype.onIdle = function(fn) {
      return _idleCallbacks.push(fn);
    };

    NoteRecorder.prototype.onUpdate = function(fn) {
      return _updateCallbacks.push(fn);
    };

    NoteRecorder.prototype.sequenceDeltas = function() {
      var el, i, j, len, ref, results;
      ref = this.sequence;
      results = [];
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        el = ref[i];
        results.push(el - this.sequence[0]);
      }
      return results;
    };

    NoteRecorder.prototype.reset = function() {
      this.idleDuration = 0;
      return this.sequence = [];
    };

    return NoteRecorder;

  })();

}).call(this);


// Generated by CoffeeScript 1.10.0
(function() {
  var LOGGED_IN, arrayEquals, cHeight, cWidth, canvas, ctx, currentClass, currentSequence, inClass, nr, outClass, setLoginState, setPasswordField;

  $(Audio.startRecording);

  window.Sequences = [
    {
      relativePitches: [0],
      action: "STOP"
    },
    {
      relativePitches: [0, -15, 0, -48, -68],
      action: "Dinos"
    }
  ];

  arrayEquals = function(arr, arr2, tolerance) {
    var el, i, j, len;
    if (tolerance == null) {
      tolerance = 15;
    }
    if (arr.length !== arr2.length) {
      return false;
    }
    for (i = j = 0, len = arr2.length; j < len; i = ++j) {
      el = arr2[i];
      if (el < (arr[i] - tolerance) || el > (arr[i] + tolerance)) {
        return false;
      }
    }
    return true;
  };

  currentSequence = [];

  window.Authentication = {
    setPassword: function(sequence) {
      currentSequence = sequence;
    },
    login: function(sequence) {
      var j, len, predefinedSequence;
      if (sequence) {
        Authentication.setPassword(sequence);
      }
      console.log(currentSequence);
      for (i = Sequences.length-1; i >= 0; i--) {
        predefinedSequence = Sequences[i];
        if (arrayEquals(currentSequence, predefinedSequence.relativePitches)) {
          chrome.runtime.sendMessage({shutdown: predefinedSequence.action}, function(response){
          });
          console.log("success");
        }
      }
    }
  };

  Audio.onError(function() {
    return alert("There was a problem accessing the audio.\nPlease check permissions.");
  });

  Audio.onUpdate(function() {
    var i, j, len, ref, results, spacing, val;
    spacing = cWidth / Audio.options.spectrumRange;
    ref = Audio.spectrum;
    results = [];
    for (i = j = 0, len = ref.length; j < len; i = ++j) {
      val = ref[i];
    }
    return results;
  });

  nr = new NoteRecorder(Audio);

  nr.onUpdate(function() {
    return Authentication.setPassword(nr.sequenceDeltas(nr.sequence));
  });

  nr.onIdle(function() {
    Authentication.login();
    return Authentication.setPassword([]);
  });

}).call(this);
